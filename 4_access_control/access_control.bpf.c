// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
/* Copyright (c) 2020 Facebook */
/* Adapted by yanniszark in 2024 */

// access_control.bpf.c is a simple access control program.

// vmlinux.h is the only file you will need to get kernel definitions!
// It is generated by bpftool and contains all the kernel definitions.
#include "vmlinux.h"

#include <bpf/bpf_endian.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

char LICENSE[] SEC("license") = "Dual BSD/GPL";

#define EPERM 1

// Map of type hash (essentially a key-value store)
// Key: user id
// Value: true if user is compromised, false otherwise
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, u64);
    __type(value, bool);
    __uint(max_entries, 100);
} compromised_users SEC(".maps");

inline bool is_user_compromised() {
    u64 uid_gid = bpf_get_current_uid_gid();
    u64 uid = uid_gid & 0xFFFFFFFF;
    bool *is_compromised = bpf_map_lookup_elem(&compromised_users, &uid);
    if (is_compromised != NULL && *is_compromised) {
        // Yes, user is compromised.
        bpf_printk("User %d is compromised\n", uid);
        return true;
    }
    return false;
}

SEC("lsm/file_open")
int BPF_PROG(lsm_access_control_open, struct file *file, int ret) {
    // ret is the return value from the previous BPF program
    // or 0 if it's the first hook.
    if (ret != 0) {
        return ret;
    }
    // Is intrusion detected?
    if (is_user_compromised()) {
        return -EPERM;
    }
    return 0;
}

SEC("lsm/file_permission")
int BPF_PROG(lsm_access_control_file_permission, struct file *file, int mask,
             int ret) {
    // ret is the return value from the previous BPF program
    // or 0 if it's the first hook.
    if (ret != 0) {
        return ret;
    }
    // Is intrusion detected?
    if (is_user_compromised()) {
        return -EPERM;
    }
    return 0;
}
